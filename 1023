<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <title>åœ£è¯æ ‘ AR ä¸‹é›ªç‰¹æ•ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #tip { position: absolute; top: 20px; left: 0; right: 0; text-align: center; color: #fff; font-size: 18px; background: rgba(0,0,0,0.6); padding: 12px; z-index: 10; border-radius: 8px; }
        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; color: #0ff; font-size: 20px; }
        .spinner { width: 60px; height: 60px; border: 5px solid #333; border-top: 5px solid #0ff; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="loader"><div class="spinner"></div><div>åŠ è½½åœ£è¯æ ‘ä¸é›ªèŠ±...</div></div>
    <div id="tip">åœ£è¯å¿«ä¹ï¼é›ªèŠ±æ­£åœ¨é£˜è½ï½ç‚¹å‡»å±å¹•æ—‹è½¬è§†è§’ ğŸ„â„ï¸</div>

    <script type="module">
        // ä¸‹é›ªç²’å­ç³»ç»Ÿ
        class SnowParticles {
            constructor(scene) {
                this.count = 8000;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(this.count * 3);
                for(let i = 0; i < this.count; i++) {
                    pos[i*3]   = (Math.random() - 0.5) * 50;
                    pos[i*3+1] = Math.random() * 30 + 10;
                    pos[i*3+2] = (Math.random() - 0.5) * 50;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const mat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8});
                this.points = new THREE.Points(geo, mat);
                this.positions = pos;
                scene.add(this.points);
            }
            update() {
                const pos = this.positions;
                for(let i = 0; i < this.count; i++) {
                    pos[i*3+1] -= 0.06 + Math.random() * 0.03;
                    if(pos[i*3+1] < -5) {
                        pos[i*3+1] = 30;
                        pos[i*3] = (Math.random() - 0.5) * 50;
                        pos[i*3+2] = (Math.random() - 0.5) * 50;
                    }
                }
                this.points.geometry.attributes.position.needsUpdate = true;
            }
        }

        // åœºæ™¯è®¾ç½®
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x001122);
        const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 8);

        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // ç¯å…‰
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const light = new THREE.PointLight(0xffaa00, 2, 50);
        light.position.set(0, 10, 0);
        scene.add(light);

        // æ‰‹å·¥æ­å»ºåœ£è¯æ ‘
        function createChristmasTree() {
            const treeGroup = new THREE.Group();

            // æ ‘å¹²
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 3, 8);
            const trunkMat = new THREE.MeshBasicMaterial({color: 0x8B4513});
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.5;
            treeGroup.add(trunk);

            // æ ‘å¶å±‚ï¼ˆä»ä¸‹åˆ°ä¸Šè¶Šæ¥è¶Šå°ï¼‰
            const layers = 5;
            for(let i = 0; i < layers; i++) {
                const height = 3 - i * 0.4;
                const radius = 2.5 - i * 0.5;
                const coneGeo = new THREE.ConeGeometry(radius, height, 12);
                const coneMat = new THREE.MeshBasicMaterial({color: 0x0f8f0f});
                const cone = new THREE.Mesh(coneGeo, coneMat);
                cone.position.y = 3 + i * (height - 0.5);
                treeGroup.add(cone);
            }

            // é¡¶ä¸Šæ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(0.8, 0);
            const starMat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 3 + layers * 2.2;
            treeGroup.add(star);

            // å½©ç¯ç²’å­ï¼ˆé—ªçƒæ•ˆæœï¼‰
            const lightsCount = 200;
            const lightGeo = new THREE.BufferGeometry();
            const lightPos = new Float32Array(lightsCount * 3);
            const lightColors = new Float32Array(lightsCount * 3);
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
            for(let i = 0; i < lightsCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 0.5 + Math.random() * 2;
                const height = 2 + Math.random() * 8;
                lightPos[i*3]   = Math.sin(angle) * radius;
                lightPos[i*3+1] = height;
                lightPos[i*3+2] = Math.cos(angle) * radius;
                const col = colors[Math.floor(Math.random() * colors.length)];
                lightColors[i*3] = (col >> 16)/255;
                lightColors[i*3+1] = ((col >> 8) & 0xff)/255;
                lightColors[i*3+2] = (col & 0xff)/255;
            }
            lightGeo.setAttribute('position', new THREE.BufferAttribute(lightPos, 3));
            lightGeo.setAttribute('color', new THREE.BufferAttribute(lightColors, 3));
            const lightMat = new THREE.PointsMaterial({size: 0.3, vertexColors: true, blending: THREE.AdditiveBlending});
            const lights = new THREE.Points(lightGeo, lightMat);
            treeGroup.add(lights);

            treeGroup.scale.set(1.2, 1.2, 1.2);
            scene.add(treeGroup);
        }

        createChristmasTree();
        const snow = new SnowParticles(scene);

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            snow.update();
            scene.rotation.y += 0.001; // æ ‘ç¼“æ…¢æ—‹è½¬
            renderer.render(scene, camera);
        }
        animate();

        // çª—å£è°ƒæ•´
        addEventListener('resize', () => {
            camera.aspect = innerWidth/innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        // éšè—åŠ è½½
        document.getElementById('loader').remove();
    </script>
</body>
</html>
